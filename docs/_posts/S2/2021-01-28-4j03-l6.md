---
layout: post
title:  "4J03 - Lecture 6"
date:   2021-01-28 15:30:00 -0500
categories: 4J03
---

Media Access Control
===

Multiple Access Media
- Multiple senders on some media
    - Buses (Ethernet, all connecting off one line)
    - Wireless, Satellite (Shared)
    - Token Ring (Connected to one another)
- Need methods to moderate access to media
    - Fair arbitration (each node has equal access)
    - Good performance (overall throughput maxed)
- Why don't we adopt fully connected network topology as LAN (local area network) topology?
    - No need for packet switching, but the number of connections grows quadratically with the number of nodes, so it is impractical with many devices
        ![img]({{ site.url }}/assets/4j03/lan.PNG) 

Multiple Access Control
- **Problem**: Demands can conflict (eg. two hosts send simultaneously)
    - Solution is a **Medium Access Control (MAC) algorithm**
- **Potential Solutions** (of many)
    - Carrier sense multiple access with collision detections (CSMA/CD)
        - Send only if medium is idle
        - Stop sending immediately if collision detected
    - Carrier sense multiple access with collision avoidance (CSMA/CA)
    - Token ring/fiber distributed data interface (FDDA)
        - Pass a token around a ring, only token holder sends

Carrier Sense Multiple Access with Collision Detection (CSMA/CD)
- Used by Ethernet
    - Xerox and IEEE 802.3 (10Mbps standard)
    - IEEE 802.3u (Fast ethernet, 100Mbps standard)
    - Current Cat7 cable offers 10Gbps within 100m
- Goal: **Distributed** algorithm that provides **fair and efficient** access to a share medium

Ethernet MAC Algorithm
- Sender/Transmitter
    - If line is idle:
        - Send immediately
        - Send maximum of 1500B data
        - Wait 9.6 $\mu s$ before sending again
    - If line is busy
        - Wait until line becomes idle
        - When idle, send immediately (called **1-persistent strategy**)
    - If collision detected
        - Stop sending and jam signal (inform other nodes that a collision occurred, letting them know to discard the message)
        - Try again later
- Given the following image;
    ![img]({{ site.url }}/assets/4j03/nab.PNG) 
    How can we ensure that *A* knows about the collision?
- **Collision Detection**
    - Example
        - Node A's message reaches node B at time *T*
        - Node B's message reaches node A at time *2T*
        - For node A to detect a collision, node *A* must still be transmitting at time *2T*
    - For 802.3...
        - *2T* is bounded to 51.2 $\mu s \rightarrow$ Distance limit of Ethernet is 7000m
        - At 10Mbps, 51.2 $\mu s$ = 512b, or 64B
        - Packet length $\geq$ 64B $\rightarrow$ If capacity is getting larger, the packet size should be larger accordingly
    - Jam after collision
        - Ensures that all hosts notice the collision
- At time *2T*, *A* is still transmitting and notices a collision
    ![img]({{ site.url }}/assets/4j03/nab2.PNG) 

Multiple Access Control
- Ethernet
    - All hosts share a bus  
        ![img]({{ site.url }}/assets/4j03/sbus.PNG) 
    - CSMA/CD
        - Collision detection
        - Exponential backoff
        - Inserting jam after collision
- 802.3
    - 2T is bounded to $51.2 \mu s$
    - Minimum allowed packet size is $10 Mbps * 51.2 \mu s = 512 b = 64B$
        - Hence, packet size $\geq 64B$
        - If capacity is getting larger, the packet size should be larger accordingly

Retransmission
- How long should a host wait to retry after a collision?
    - **Binary exponential backoff**
        - Backoff window size is power of 2, initially window size is 1 ($2^0$)
        - A node (discretely) randomly selects a slot in the window to represent the start transmission time
        - Backoff window size doubles with each failure
        - After *N* failures, $2^N$ is the window size, and there are $2^N$ discrete possibilities of transmission time
    - If busy, backoff window will be larger, and if not, backoff window will be smaller
- Consider the following w.r.t binary exponential backoff
    - *k* hosts collide
    - Eac picks a random number from $0$ to $2^N - 1$
    - If the minimum value is unique
        - All other hosts see a busy line
    - If the minimum value is not unique
        - Hosts with the minimum value slot collide again
        - Will then consider the next smallest backoff value

Wireless
- IEEE 802.11
    - A physical and multiple access layer standard for wireless local area networks (WLAN)  
        ![img]({{ site.url }}/assets/4j03/wlan.PNG) 
- IEEE 802.11 MAC Layer Standard
    - MAC layer standard for this is similar to ethernet (if two nodes are communicating simultaneously, collision can occur)
- Consider the following image of a **hidden terminal problem**, where A and C are both trying to communicate to B, but they cannot see each other, so they would both believe the signal is idle and send whenever, which could cause a collision at B, which A and C would not be aware of:  
    ![img]({{ site.url }}/assets/4j03/htp.PNG)
    - The solution to this would be to implement a **Request to Send (RTS)** signal from the sender before transmission and a **Clear to Send (CTS)** signal from the receiver to any systems in the network to let it know that the network is clear and it is safe to transmit to B and let other nodes like C know not to transmit anything
        ![img]({{ site.url }}/assets/4j03/htps.PNG)
- Another problem is the **exposed terminal problem**, where B is transmitting to A, and C wants to transmit to D. When B is transmitting to A, then C will hear this and think the line is idle and not communicate with D. It could logically communicate, since the lines to not collide, but C will not since it does not see the line as idle:  
    ![img]({{ site.url }}/assets/4j03/etp.PNG) 
    - The solution to this would also be through a RTS and CTS system, in which A and B can send their messages, and since C did not hear the CTS signal, it can send to D as well  
        ![img]({{ site.url }}/assets/4j03/etps.PNG) 
- 


    