<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Regular Expression Power Hour üî§ | Giacomo</title><meta name=keywords content="research,code"><meta name=description content="Also known as &ldquo;String Comprehension&rdquo;, &ldquo;Code Within Code&rdquo;, and &ldquo;Annoying&rdquo;"><meta name=author content="Giacomo Loparco"><link rel=canonical href=https://loparcog.github.io/posts/2303regex/><link crossorigin=anonymous href=/assets/css/stylesheet.f417b2b78a51a3f1015eb588a750379d079f7aca74d3fc689d30c120942e444c.css integrity="sha256-9Beyt4pRo/EBXrWIp1A3nQefesp00/xonTDBIJQuREw=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://loparcog.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://loparcog.github.io/img/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://loparcog.github.io/img/favicon-32x32.png><link rel=apple-touch-icon href=https://loparcog.github.io/img/apple-touch-icon.png><link rel=mask-icon href=https://loparcog.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="Regular Expression Power Hour üî§"><meta property="og:description" content="Also known as &ldquo;String Comprehension&rdquo;, &ldquo;Code Within Code&rdquo;, and &ldquo;Annoying&rdquo;"><meta property="og:type" content="article"><meta property="og:url" content="https://loparcog.github.io/posts/2303regex/"><meta property="og:image" content="https://loparcog.github.io/img/pfp.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-31T12:00:00-05:00"><meta property="article:modified_time" content="2023-03-31T12:00:00-05:00"><meta property="og:site_name" content="Giacomo"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://loparcog.github.io/img/pfp.png"><meta name=twitter:title content="Regular Expression Power Hour üî§"><meta name=twitter:description content="Also known as &ldquo;String Comprehension&rdquo;, &ldquo;Code Within Code&rdquo;, and &ldquo;Annoying&rdquo;"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://loparcog.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Regular Expression Power Hour üî§","item":"https://loparcog.github.io/posts/2303regex/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Regular Expression Power Hour üî§","name":"Regular Expression Power Hour üî§","description":"Also known as \u0026ldquo;String Comprehension\u0026rdquo;, \u0026ldquo;Code Within Code\u0026rdquo;, and \u0026ldquo;Annoying\u0026rdquo;","keywords":["research","code"],"articleBody":"I‚Äôve decided that recipes have all the fun injecting life stories into their posts and I want to change that.\nA brief (personal) history A regular expression, or regex, is a pattern defined by a series of characters to search for specific data in text. This definition is extremely basic since the application of regexes is extremely broad. If you ever needed to pull out specific pieces of a string, or certain lines of a file with a certain phrase or pattern, regex will be your best friend. Regex is also a great start for any other pattern-based parsers you might run into (like Grok for example).\nThroughout my university career, I was well aware that regex existed and probably used it once or twice, but I didn‚Äôt really pay it any attention past that. Things only started to get intimate was in my first programming position, where I naively took on a project to localize our entire codebase. Thanks to regex, I was able to parse through our code files programmatically to find and replace any strings with localized references, however this task was a few weeks in comparison to the few days it took to squash low-level bugs.\nNow I find myself in a similar position working on a lovely open-source project Isobar, looking to programmatically pull comments out of Python files for documentation. I also thought this would be a good excuse to write an article on regex.\nBasics of regex Feel free to open up a free online regex tester like Regex101 to try any of the following!\nRegex patterns can change from language to language, but they will traditionally follow the pattern /pattern/flags. The pattern section will hold your query, while the flags will dictate settings like case insensitivity and multi-line searches. Here‚Äôs an example in python:\n\u003e\u003e\u003e import re # Search follows the format (pattern, text to search, flags), and does not require forward slashes \u003e\u003e\u003e pattern = \"[aeiou]\\w\" \u003e\u003e\u003e text = \"Hello, World!\" # Search and print all matches \u003e\u003e\u003e re.search(pattern,text) \u003e\u003e\u003e print(re.groups()) (\"el\", \"or\") This pattern is looking for a vowel ([aeiou]) followed by any ‚Äúword character‚Äù, which is any letter, number, or underscore (\\w, or [a-zA-Z0-9_]). So within our phrase, the pattern matches ‚ÄúHello, World!‚Äù. While we‚Äôre at it, lets look at some basic regex syntax:\nAs a basis, any character can be put into a regex search to look for that singular character or sequence of characters, however there are some meta characters that will be described below. If you just want to search for one of these characters instead of using it as a meta character, you can escape it using a backslash (\\). For example, searching for a period . would look like \\. in a regex string. The following are all regex meta characters:\n. \\ * + ? | ^ $ [ ] ( ) { }\nGroups define explicit characters to look for:\nGroup Symbol Definition [ ... ] Look for any characters in this group (NOTE: Meta characters don‚Äôt need to be escaped in these) [^ ... ] Look for any characters NOT in this group ( ... ) Create a subexpression to isolate a specific section of your pattern and/or apply a modifier to a regex pattern (modifiers described below) ( A | B ) Match with pattern A OR B Tokens are shorthand for capture groups and specific pieces of text:\nToken Definition \\s Any whitespace including spaces, tabs, and newlines[ \\t\\n\\r] \\d Any number, excluding any operation symbols [0-9]+ \\w Any word built from letters, numbers, and underscores[a-zA-Z0-9_] . Any character ^ Marks the beginning of the queried text $ Marks the end of the queried text NOTE: Any of the character tokens above can be capitalized to capture their negative group (eg. anything but whitespace would be \\S)\nModifiers go after a token or group to dictate a quantity to look for:\nModifier Definition ? 0 or 1 * 0 or more + 1 or more {n} Exactly n {n,} n or more {n,m} Between n and m All of this alone will cover a large majority of your regex queries. You can put together any combination of the above to get specific pieces and quotes of any basic text.\nBut what if we want to push regex further? Like, for example, if we wanted to match multiple possible formats in a piece of code to pull inline text?\nThe problem at hand Each pattern class in isobar may have comments below it that define the class. This comment may include a short description, longer description, and example output:\nclass PExample(Pattern): \"\"\" PExample short description PExample long description which can be multiple lines \u003e\u003e\u003e PExample(example_input) \u003e\u003e\u003e example_output \"\"\" The main challenges here are that we need to get everything surrounded by the characters \"\"\" and divide it into its respective parts, if those parts exist, or if the class comment exists to begin with.\nString parsing around different character groups that will exist multiple times in a file and pulling out this specific information is where our basic approach starts to show its flaws. All of the tools above will still be used, but we will need more to make our queries more precise, using a dagger instead of a zweihander.\nA simple way to show this is through an example. Say we have the following text to parse:\nclass PClass1(Pattern): \"\"\" Hello, \"\"\" class PClass2(Pattern): \"\"\" World! \"\"\" How can we make sure that we‚Äôre only getting the first comment? Assuming we‚Äôre using the flag s to allow for . to match with newlines, some things that could be worth a try would be‚Ä¶\n\"\"\".*\"\"\": Matches BOTH comments, from the start of PClass1‚Äôs to the end of PClass2‚Äôs \"\"\"[^\"]*\"\"\": This works, but would break if there is a quotation mark in the comment What we‚Äôre missing with our current tool set is something to see groups before and after our search, to make sure that we can stop at the first occurrence of a given series of characters. Thankfully, this is possible!\nAdvanced regex When you can‚Äôt find something with basic regex, chances are there is some advanced syntax that will do exactly what you‚Äôre hoping for. There are a number of different methods, wonderfully documented across the internet, these are two that I have found the most useful:\nLazy Quantifier Dan brought this to my attention while troubleshooting and I‚Äôm so surprised I have made it this far without having this committed to memory. A lazy quantifier would do exactly what we‚Äôre looking for in our first pattern attempt above, matching the LEAST amount of characters possible. This can be done by appending a question mark (?) after any quantifier (?, +, or *).\nUsing this, we can edit our previous query to use a lazy modifier: \"\"\".*?\"\"\", which will now only match the PClass1 comment without continuing on! Score!\nLook Ahead/Behind Another method which I have used constantly is a filter to look for anything before or after a given query without matching it. This is also a very useful tool to put bounds into your pattern. This can be done with the following patterns:\nGroup Definition (?=xyz) Positive lookahead (?!xyz) Negative lookahead (?\u003c=xyz) Positive lookbehind (?\u003c!xyz) Negative lookbehind These can help to narrow down your match to only capture the content you want, putting conditions around your searched area. You can also use this with capture groups to create interesting use cases, like a workaround lazy quantifier!\nWe can replicate the previous query, replacing the lazy quantifier with a negative lookahead capture group: \"\"\"((?!\"\"\").)*\"\"\". In this case, it is obviously better to use the lazy quantifier, but this leaves interesting possibilities for changing the content the lookahead/behind is looking for to different character sets for complex queries.\nConsiderations I am in no way a regex expert and this is in no way a complete guide. I have just went through a bunch of regex work and wanted a place to document some of this, as well as anything else I come across. My usual regex works are few and far between, but they also usually dive very deep, to the point of learning something new each time.\nWill I remember to put it here? Let‚Äôs see!\n","wordCount":"1380","inLanguage":"en","datePublished":"2023-03-31T12:00:00-05:00","dateModified":"2023-03-31T12:00:00-05:00","author":{"@type":"Person","name":"Giacomo Loparco"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://loparcog.github.io/posts/2303regex/"},"publisher":{"@type":"Organization","name":"Giacomo","logo":{"@type":"ImageObject","url":"https://loparcog.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://loparcog.github.io/ accesskey=h title="Giacomo (Alt + H)">Giacomo</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://loparcog.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://loparcog.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://loparcog.github.io/animals/ title=animals><span>animals</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://loparcog.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://loparcog.github.io/posts/>Posts</a></div><h1 class=post-title>Regular Expression Power Hour üî§</h1><div class=post-meta><span title='2023-03-31 12:00:00 -0500 -0500'>March 31, 2023</span>&nbsp;¬∑&nbsp;7 min&nbsp;¬∑&nbsp;Giacomo Loparco</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#a-brief-personal-history>A brief (personal) history</a></li><li><a href=#basics-of-regex>Basics of regex</a></li><li><a href=#the-problem-at-hand>The problem at hand</a></li><li><a href=#advanced-regex>Advanced regex</a><ul><li><a href=#lazy-quantifier>Lazy Quantifier</a></li><li><a href=#look-aheadbehind>Look Ahead/Behind</a></li></ul></li><li><a href=#considerations>Considerations</a></li></ul></nav></div></details></div><div class=post-content><p><em>I&rsquo;ve decided that recipes have all the fun injecting life stories into their posts and I want to change that.</em></p><h2 id=a-brief-personal-history>A brief (personal) history<a hidden class=anchor aria-hidden=true href=#a-brief-personal-history>#</a></h2><p>A regular expression, or <em>regex</em>, is a pattern defined by a series of characters to search for specific data in text. This definition is extremely basic since the application of regexes is extremely broad. If you ever needed to pull out specific pieces of a string, or certain lines of a file with a certain phrase or pattern, regex will be your best friend. Regex is also a great start for any other pattern-based parsers you might run into (like <a href=https://www.elastic.co/guide/en/logstash/current/plugins-filters-grok.html>Grok</a> for example).</p><p>Throughout my university career, I was well aware that regex existed and probably used it once or twice, but I didn&rsquo;t really pay it any attention past that. Things only started to get intimate was in my first programming position, where I naively took on a project to localize our entire codebase. Thanks to regex, I was able to parse through our code files programmatically to find and replace any strings with localized references, however this task was a few weeks in comparison to the few days it took to squash low-level bugs.</p><p>Now I find myself in a similar position working on a lovely open-source project <a href=https://github.com/ideoforms/isobar/>Isobar</a>, looking to programmatically pull comments out of Python files for documentation. I also thought this would be a good excuse to write an article on regex.</p><h2 id=basics-of-regex>Basics of regex<a hidden class=anchor aria-hidden=true href=#basics-of-regex>#</a></h2><p><em>Feel free to open up a free online regex tester like <a href=https://regex101.com/>Regex101</a> to try any of the following!</em></p><p>Regex patterns can change from language to language, but they will traditionally follow the pattern <code>/pattern/flags</code>. The <code>pattern</code> section will hold your query, while the <code>flags</code> will dictate settings like case insensitivity and multi-line searches. Here&rsquo;s an example in python:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#f92672>import</span> re
</span></span><span style=display:flex><span><span style=color:#75715e># Search follows the format (pattern, text to search, flags), and does not require forward slashes</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> pattern <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;[aeiou]\w&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> text <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello, World!&#34;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Search and print all matches</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> re<span style=color:#f92672>.</span>search(pattern,text)
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> print(re<span style=color:#f92672>.</span>groups())
</span></span><span style=display:flex><span>(<span style=color:#e6db74>&#34;el&#34;</span>, <span style=color:#e6db74>&#34;or&#34;</span>)
</span></span></code></pre></div><p>This pattern is looking for a vowel (<code>[aeiou]</code>) followed by any &ldquo;word character&rdquo;, which is any letter, number, or underscore (<code>\w</code>, or <code>[a-zA-Z0-9_]</code>). So within our phrase, the pattern matches &ldquo;H<strong>el</strong>lo, W<strong>or</strong>ld!&rdquo;. While we&rsquo;re at it, lets look at some basic regex syntax:</p><p>As a basis, <strong>any character</strong> can be put into a regex search to look for that singular character or sequence of characters, however there are some <strong>meta characters</strong> that will be described below. If you just want to search for one of these characters instead of using it as a meta character, you can escape it using a backslash (<code>\</code>). For example, searching for a period <code>.</code> would look like <code>\.</code> in a regex string. The following are all regex meta characters:</p><p><code>. \ * + ? | ^ $ [ ] ( ) { }</code></p><p><strong>Groups</strong> define explicit characters to look for:</p><table><thead><tr><th>Group Symbol</th><th>Definition</th></tr></thead><tbody><tr><td><code>[ ... ]</code></td><td>Look for any characters in this group (NOTE: Meta characters don&rsquo;t need to be escaped in these)</td></tr><tr><td><code>[^ ... ]</code></td><td>Look for any characters <strong>NOT</strong> in this group</td></tr><tr><td><code>( ... )</code></td><td>Create a subexpression to isolate a specific section of your pattern and/or apply a modifier to a regex pattern (modifiers described below)</td></tr><tr><td><code>( A | B )</code></td><td>Match with pattern <code>A</code> OR <code>B</code></td></tr></tbody></table><p><strong>Tokens</strong> are shorthand for capture groups and specific pieces of text:</p><table><thead><tr><th>Token</th><th>Definition</th></tr></thead><tbody><tr><td><code>\s</code></td><td>Any whitespace including spaces, tabs, and newlines<code>[ \t\n\r]</code></td></tr><tr><td><code>\d</code></td><td>Any number, excluding any operation symbols <code>[0-9]+</code></td></tr><tr><td><code>\w</code></td><td>Any word built from letters, numbers, and underscores<code>[a-zA-Z0-9_]</code></td></tr><tr><td><code>.</code></td><td>Any character</td></tr><tr><td><code>^</code></td><td>Marks the beginning of the queried text</td></tr><tr><td><code>$</code></td><td>Marks the end of the queried text</td></tr></tbody></table><p><strong>NOTE:</strong> Any of the character tokens above can be capitalized to capture their negative group (eg. anything <strong>but</strong> whitespace would be <code>\S</code>)</p><p><strong>Modifiers</strong> go after a token or group to dictate a quantity to look for:</p><table><thead><tr><th>Modifier</th><th>Definition</th></tr></thead><tbody><tr><td><code>?</code></td><td>0 or 1</td></tr><tr><td><code>*</code></td><td>0 or more</td></tr><tr><td><code>+</code></td><td>1 or more</td></tr><tr><td><code>{n}</code></td><td>Exactly <em>n</em></td></tr><tr><td><code>{n,}</code></td><td><em>n</em> or more</td></tr><tr><td><code>{n,m}</code></td><td>Between <em>n</em> and <em>m</em></td></tr></tbody></table><p>All of this alone will cover a large majority of your regex queries. You can put together any combination of the above to get specific pieces and quotes of any basic text.</p><p>But what if we want to push regex further? Like, for example, if we wanted to match multiple possible formats in a piece of code to pull inline text?</p><h2 id=the-problem-at-hand>The problem at hand<a hidden class=anchor aria-hidden=true href=#the-problem-at-hand>#</a></h2><p>Each pattern class in isobar <em>may</em> have comments below it that define the class. This comment <em>may</em> include a short description, longer description, and example output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PExample</span>(Pattern):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    PExample short description
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    PExample long description which can be
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    multiple
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    lines
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &gt;&gt;&gt; PExample(example_input)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &gt;&gt;&gt; example_output
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span></code></pre></div><p>The main challenges here are that we need to get everything surrounded by the characters <code>"""</code> and divide it into its respective parts, <em>if those parts exist</em>, or if the class comment exists to begin with.</p><p>String parsing around different character groups that will exist multiple times in a file and pulling out this specific information is where our basic approach starts to show its flaws. All of the tools above will still be used, but we will need more to make our queries more precise, using a dagger instead of a zweihander.</p><p>A simple way to show this is through an example. Say we have the following text to parse:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PClass1</span>(Pattern):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Hello,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PClass2</span>(Pattern):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    World!
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span></code></pre></div><p>How can we make sure that we&rsquo;re only getting the first comment? Assuming we&rsquo;re using the flag <code>s</code> to allow for <code>.</code> to match with newlines, some things that could be worth a try would be&mldr;</p><ul><li><code>""".*"""</code>: Matches BOTH comments, from the start of <code>PClass1</code>&rsquo;s to the end of <code>PClass2</code>&rsquo;s</li><li><code>"""[^"]*"""</code>: This works, but would break if there is a quotation mark in the comment</li></ul><p>What we&rsquo;re missing with our current tool set is something to see groups <strong>before</strong> and <strong>after</strong> our search, to make sure that we can stop at the first occurrence of a given series of characters. Thankfully, this is possible!</p><h2 id=advanced-regex>Advanced regex<a hidden class=anchor aria-hidden=true href=#advanced-regex>#</a></h2><p>When you can&rsquo;t find something with basic regex, chances are there is some advanced syntax that will do exactly what you&rsquo;re hoping for. There are a number of different methods, wonderfully documented across the internet, these are two that I have found the most useful:</p><h3 id=lazy-quantifier>Lazy Quantifier<a hidden class=anchor aria-hidden=true href=#lazy-quantifier>#</a></h3><p>Dan brought this to my attention while troubleshooting and I&rsquo;m so surprised I have made it this far without having this committed to memory. A lazy quantifier would do exactly what we&rsquo;re looking for in our first pattern attempt above, matching the LEAST amount of characters possible. This can be done by appending a question mark (<code>?</code>) after any quantifier (<code>?</code>, <code>+</code>, or <code>*</code>).</p><p>Using this, we can edit our previous query to use a lazy modifier: <code>""".*?"""</code>, which will now only match the <code>PClass1</code> comment without continuing on! Score!</p><h3 id=look-aheadbehind>Look Ahead/Behind<a hidden class=anchor aria-hidden=true href=#look-aheadbehind>#</a></h3><p>Another method which I have used constantly is a filter to look for anything before or after a given query without matching it. This is also a very useful tool to put bounds into your pattern. This can be done with the following patterns:</p><table><thead><tr><th>Group</th><th>Definition</th></tr></thead><tbody><tr><td><code>(?=xyz)</code></td><td>Positive lookahead</td></tr><tr><td><code>(?!xyz)</code></td><td>Negative lookahead</td></tr><tr><td><code>(?&lt;=xyz)</code></td><td>Positive lookbehind</td></tr><tr><td><code>(?&lt;!xyz)</code></td><td>Negative lookbehind</td></tr></tbody></table><p>These can help to narrow down your match to only capture the content you want, putting conditions around your searched area. You can also use this with capture groups to create interesting use cases, like a workaround lazy quantifier!</p><p>We can replicate the previous query, replacing the lazy quantifier with a negative lookahead capture group: <code>"""((?!""").)*"""</code>. In this case, it is obviously better to use the lazy quantifier, but this leaves interesting possibilities for changing the content the lookahead/behind is looking for to different character sets for complex queries.</p><h2 id=considerations>Considerations<a hidden class=anchor aria-hidden=true href=#considerations>#</a></h2><p>I am in no way a regex expert and this is in no way a complete guide. I have just went through a bunch of regex work and wanted a place to document some of this, as well as anything else I come across. My usual regex works are few and far between, but they also usually dive very deep, to the point of learning something new each time.</p><p>Will I remember to put it here? Let&rsquo;s see!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://loparcog.github.io/tags/research/>research</a></li><li><a href=https://loparcog.github.io/tags/code/>code</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://loparcog.github.io/>Giacomo</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>