<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Envelope Detector Research and Ramblings ✉️ | Giacomo</title><meta name=keywords content="synth,research"><meta name=description content="Looking into different envelope detecting methods for a future sidechaining module"><meta name=author content="Giacomo Loparco"><link rel=canonical href=https://loparcog.github.io/posts/2212envelope/><link crossorigin=anonymous href=/assets/css/stylesheet.f417b2b78a51a3f1015eb588a750379d079f7aca74d3fc689d30c120942e444c.css integrity="sha256-9Beyt4pRo/EBXrWIp1A3nQefesp00/xonTDBIJQuREw=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://loparcog.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://loparcog.github.io/img/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://loparcog.github.io/img/favicon-32x32.png><link rel=apple-touch-icon href=https://loparcog.github.io/img/apple-touch-icon.png><link rel=mask-icon href=https://loparcog.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="Envelope Detector Research and Ramblings ✉️"><meta property="og:description" content="Looking into different envelope detecting methods for a future sidechaining module"><meta property="og:type" content="article"><meta property="og:url" content="https://loparcog.github.io/posts/2212envelope/"><meta property="og:image" content="https://loparcog.github.io/img/pfp.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-19T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-19T00:00:00+00:00"><meta property="og:site_name" content="Giacomo"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://loparcog.github.io/img/pfp.png"><meta name=twitter:title content="Envelope Detector Research and Ramblings ✉️"><meta name=twitter:description content="Looking into different envelope detecting methods for a future sidechaining module"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://loparcog.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Envelope Detector Research and Ramblings ✉️","item":"https://loparcog.github.io/posts/2212envelope/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Envelope Detector Research and Ramblings ✉️","name":"Envelope Detector Research and Ramblings ✉️","description":"Looking into different envelope detecting methods for a future sidechaining module","keywords":["synth","research"],"articleBody":"This is all working off of a basis of what I know and understand, so take things with a grain of salt!\nThe problem at hand I’m hoping to make a new module in VCV Rack (currently named Kyle) to act as a sidechaining module. Sidechaining is the technology that allows for music to automatically become quieter when a DJ is talking, or for other instruments to “step to the side” and quiet down each time the bass drum comes in to give it extra “oomph”. Typically, this can be done by creating an envelope for a signal, and passing an inverse that as the level to another signal, to move the volume of the latter down when the former is up.\nThis is admittedly extremely easy, but I wanted to focus on more abstract sounds. This would focus on signals where an envelope cannot be easily defined and/or signals where I am too lazy to create an envelope for. This is where an envelope detector can come in handy.\nWhat is an envelope detector An envelope detector is a tool that will map the envelope of a given waveform. The exact version of this would be an “analytic signal”, but this tool and its multiple iterations aim to replicate that analytic signal as accurately as possible.\nExample envelope from a signal, marked in red There are a few approaches to getting this result, each with their own pros and cons. The most important trait for my implementation would be reactivity, followed of course by accuracy. Any substantial delay would ruin the use of the sidechain envelope, so even with accuracy the result would be unusable.\nHow can it be implemented These are a few that I found while researching:\nDiode detector This is the simplest implementation, and probably the easiest to understand. A waveform is passed through a capacitor in a simple circuit, which charges whenever there is a high in the signal, and drains whenever there is a low. This allows it to create an almost sawtooth wave covering the envelope of a wave.\nExample implementation of a diode detector, and its downfalls As seen above though, some issues arise in its implementation. The aggression of the fall in the created envelope depends on how fast the capacitor loses charge, so if it doesn’t lose charge fast enough, as seen above, there may be a large gap between the waveform dropping and the envelope following. This is still quite useful to consider, since it is easy to implement and reacts to rises immediately, so it may be usable given some modifications.\nRectifier and low-pass filter This is where things get not-so-simple. Both this and the following method dive into some actual signal modulation to create an envelope from the original signal. I am also not the most knowledgable in this so please refer to this article’s header. From this point on, we get into signals. Most of the base information I got was from this MathWorks link. Beware.\nThis is the basic chain of this operation:\n$$\\text{Input} \\rightarrow u^2 \\rightarrow u*2 \\rightarrow \\text{Downsample} \\rightarrow \\text{LPF} \\rightarrow \\sqrt{u} \\rightarrow \\text{Output}$$\nThe input to this is the original sound waveform. This signal is rectified (or squared), to essentially make it its own carrier wave. Rectifying, for our understanding, mainly takes the loud sound wave and brings it back to a much smoother wave. From there, the signal is multiplied by 2 to help scale it up for processing, and downsampled. Downsampling removes some sampled data points, to simulate a lower sample rate and reduce the complexity of our resulting wave. Finally, a LPF, or Low Pass Filter is applied. A Low Pass Filter allows for low frequency waves, like our resulting wave, to pass through, and prevents high-frequency waves, like any small fast bumps in that wave, to be smoothed out. Finally, we take the square root of the resulting signal to scale it back down and match it to our original data.\nThis process definitely take some steps up in complexity, but it is really interesting on how it modulates the original waveform. Doing downsampling and (mainly) filtering in real time can sometimes be an issue in terms of delay, but this is something we can investigate. Essentially, this is a lot more accurate than our previous method, but a lot more expensive.\nHilbert Transform I am going to save the deepdive on this. This is something you can check out on the original MathWorks link, but it is essentially a more grandiose version of our rectifier and LPF described above. This one is seriously impressive, but again, is more computationally expensive. The main problem is that a real time Hilbert Transform is a point of high-level research, and as well that its main focus is on waveforms without massive changes. This does not match our use case.\nReally cool though.\nWhat I would like to do As mentioned above, each piece has their pros and cons. The main things I want to keep in mind though are the following:\nThis is for a real-time sidechaining module, so delay would be easily noticeable, and the ideal case would be if we could even be early. This will be a VCV Rack module at the end of the day, so we will be sharing computer resources with a wide range of other modules. Something computationally expensive may be neat in its own physical module, but would be rude in this context. With these in mind, I would mainly want to focus on an advanced version of the diode detector, maybe with some peak detection so we could be aware of jumps from high to low frequencies. The best way to discover what’s best would be through testing though, so that’s what’s next currently.\nWhat I am doing Note that this is a stream of consciousness as I’ve been updating the module over time.\nNow, for setting up a testing environment on waveform manipulation, I highly recommend looking towards Python with Scipy and MatPlotLib, so you can easily adjust parameters and see how different functions work on different waveforms. I did not do this though because I like to dive directly into the use case and also I wanted to keep momentum on this project without getting slowed down from importing different .WAVs to test on.\nSo, alternatively, I have made a rough version of this future module to test directly in VCV Rack. I am also using VCV Rack’s Scope to view the waveform I am creating, as well as Audible Instrument’s Macro Oscillator 2 (or as many of us formally know it, Plaits).\nFirst testing deployment, with prototype Kyle module T1: Diode Detector with Rectifier To start testing, the Kyle module was fitted with a diode detector implementation. This was obviously the easiest to implement, but it was also what I believed would be the closest to the final implementation of the model.\n// Abs the current value, make all peaks positive currVoltage = abs(inputs[SIGNAL_INPUT].getVoltage()); // Set the output // If the signal is greater than the current output voltage if (currVoltage \u003e outVoltage) { // Set the output to the signal voltage outVoltage = currVoltage; } // If the current output voltage is greater than the signal else { // Reduce the output by a given decay value outVoltage -= params[PDECAY_PARAM].getValue() / 1000; } // Set the output outputs[ENV_OUTPUT].setVoltage(outVoltage); I had set the module to take any signal as an input and rectify it so all peaks were positive. Then, as the signal is running, the module would either clone the signal if the voltage was higher than its current voltage, or decay at a constant amount, ranging from 0 to 1/1000 per sample, depending on the decay knob value.\nKyle module running as basic diode detector The decay, as expected, was extremely rigid. Hugging a waveform without some sort of exponential decay would definitely be an issue down the line. We could introduce some complexity into how we handle change in the waveform such as…\nExponential/logarithmic decay Decay based on current voltage (stronger at higher voltage, weaker at lower) Moving window decay (alternative of the above, looking at how radically the data changes over a certain historical period and adjusting the decay rate accordingly) Furthermore, the rigid nature of the waveform seems to really come to a head at near-constant or low change areas of the signal waveform, namely at the low voltages of our test. This is somewhere that the current voltage decay basing and/or moving window could come in handy.\nWith all of this, the next implementation of the Kyle module would include some controls for toggling between exponential or linear decay, as well as altering decay based on current voltage. The moving window is something I find interesting, but will be looked at down the line if necessary.\nT2: Diode Detector with Mass Adjustment Parameters Next try, new controls! Things have gotten undeniably worse visually but that’s what prototyping is for! Added in now are controls to change the decay type between exponential, linear, and logarithmic, as well as a knob to control how much the current voltage affects how fast the decay takes place.\nUpgraded Kyle module with more decay controls Some immediate roadblocks were shown, mainly in having a constant exponential or logarithmic decay. When tweaking the decay knob, you could get a good curve to hug any quickly dropping high peaks, but whenever the voltage reached much lower values than that peak, there would be a fuzz of the curve immediately dropping from the low voltage, to somewhere much lower than the original waveform, and then bouncing back up. This was the wake-up call that reminded me that I would need to make the exponential and logarithmic decays relative to the voltages of the original signal, rather than keep it as its own knob.\n// Exponential, return function of time float expDecay() { // e^(t * decay) * currVoltage / 10 return exp(t * (params[PDECAY_PARAM].getValue() * 10.f)) * (currVoltage / 7500.f); } // Linear, return constant decay float linDecay() { // linear, just decay return params[PDECAY_PARAM].getValue() / 1000.f; } // Logarithmic, return function of time float logDecay() { // log(t * decay) * currVoltage / 10 return std::max(0.f, log(t * (params[PDECAY_PARAM].getValue() * 10.f)) * (currVoltage / 10.f)); } I also realized that my terminology was off. The curves that I was looking to model in the decay were ones bowing inward and outwards, but the exp and log decay curves both curve outwards. To get the curves I wanted, I would be looking at an exp and inverse exp function. Because of this, and after some testing, I realized the UI could be better by having one knob control the acceleration of the curve while the other can scale the entire decay function:\n$$\\text{decay}*e^{\\text{accel}}$$\nThe decay knob would stay as-is, and the selector would then be replaced by the acceleration knob, or what will likely just be labelled exp. The voltage impact knob as seen on this demo will be removed since it is unneeded.\nSomething else I was wondering about was if we used inverse exponential decay at high amplitudes and regular exponential decay at low amplitudes, but that may be more complicated than it’s worth and would need to introduce more controls. I’ll mainly be looking at how the above works in the next iteration.\nT3: Exponential Decay Diode Detector IT MODERATELY WORKS! This is the first iteration that I am happy to use as a base to tweak for final release. Since the last try, I implemented the exp knob as described above. Negative values make it curve in while positive values make it curve out. I also added an amplification knob to multiply the output, allowing even small changes to be much more impactful for sidechain usage.\nFirst functional Kyle module with exponent customization This time around, the code has gotten quite neat and compact, to the point I can put the whole process code here pretty comfortably. Some notable changes are now scaling the decay value in relation to the sample rate to keep things consistent at different values, as well as finally implementing the inverse envelope to allow for level/VCA modulation.\n// Get input voltage (keep it positive) currVoltage = abs(inputs[SIGNAL_INPUT].getVoltage()); // Add to the timer t += args.sampleTime; /* We decay the signal either exponentially if PEXP != 0, otherwise we decay linearly out - (decay * e^(exp)) */ outVoltage = outVoltage - ((params[PDECAY_PARAM].getValue() / args.sampleRate) * exp((params[PEXP_PARAM].getValue() * t))); /* If the original signal is greater than our output voltage, currVoltage \u003e outVoltage Set the output to the signal voltage. Otherwise, use the decayed output voltage */ if (currVoltage \u003e= outVoltage) { outVoltage = currVoltage; // Reset the time t = 0.f; } outVoltage = std::max(currVoltage, outVoltage); // Amplify the output (maxing out at 10) ampOut = std::min(10.f, abs(outVoltage * (1 + 9.f * params[PAMP_PARAM].getValue()))); // Set output voltages, accounting for amplification outputs[ENV_OUTPUT].setVoltage(ampOut); outputs[ENVINV_OUTPUT].setVoltage(10 - ampOut); As usual, there is always more to fix and improve on.\nUsing a negative exponent is very cool for hugging a shrinking waveform without ever needing to hit that waveform until the next peak, but at high negative values and low decay values it does not converge to 0. This is also seen with a constant decay and decay set to 0. This could likely be fixed by checking if the input has been at or around 0 for a number of samples, and/or if anything is plugged into the unit. If this is the case, we can slowly decay the value to 0 or just jump it.\nAs mentioned in the last iteration, there could be a use for using both positive and negative exponential decay values depending on the current voltage of the signal, but I will likely leave that for a revamp of the module in the future (which I can then change $20 more for).\nI was also thinking of the possibility of adding a max and min value, scaling all voltages from the original signal above max to an output of 10V, all voltages below min to an output of 0V, and appropriately matching the central values. I’m gonna run this all by some people to see how useful it could be and if it’s worthwhile to implement.\nThe final thing to touch upon would probably be some iconography to help visually explain what different exponent values and even amplification values mean, there’s enough room for it too so why not.\nWhere from here I think Kyle has reached a stable enough point for a base release, with a lot to think on for a future refactor. Once this module releases, the Kyle, Sesame, and Lola modules will all be reviewed to add in any extra features as well as resource test to confirm they’ll work well in VCV Rack. Finally, assuming all this goes well, they’ll be submitted to the VCV Library. Until then, I write.\n","wordCount":"2495","inLanguage":"en","datePublished":"2022-12-19T00:00:00Z","dateModified":"2022-12-19T00:00:00Z","author":{"@type":"Person","name":"Giacomo Loparco"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://loparcog.github.io/posts/2212envelope/"},"publisher":{"@type":"Organization","name":"Giacomo","logo":{"@type":"ImageObject","url":"https://loparcog.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://loparcog.github.io/ accesskey=h title="Giacomo (Alt + H)">Giacomo</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://loparcog.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://loparcog.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://loparcog.github.io/animals/ title=animals><span>animals</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://loparcog.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://loparcog.github.io/posts/>Posts</a></div><h1 class=post-title>Envelope Detector Research and Ramblings ✉️</h1><div class=post-meta><span title='2022-12-19 00:00:00 +0000 UTC'>December 19, 2022</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Giacomo Loparco</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#the-problem-at-hand>The problem at hand</a></li><li><a href=#what-is-an-envelope-detector>What is an envelope detector</a></li><li><a href=#how-can-it-be-implemented>How can it be implemented</a><ul><li><a href=#diode-detector>Diode detector</a></li><li><a href=#rectifier-and-low-pass-filter>Rectifier and low-pass filter</a></li><li><a href=#hilbert-transform>Hilbert Transform</a></li></ul></li><li><a href=#what-i-would-like-to-do>What I would like to do</a></li><li><a href=#what-i-am-doing>What I am doing</a><ul><li><a href=#t1-diode-detector-with-rectifier>T1: Diode Detector with Rectifier</a></li><li><a href=#t2-diode-detector-with-mass-adjustment-parameters>T2: Diode Detector with Mass Adjustment Parameters</a></li><li><a href=#t3-exponential-decay-diode-detector>T3: Exponential Decay Diode Detector</a></li></ul></li><li><a href=#where-from-here>Where from here</a></li></ul></nav></div></details></div><div class=post-content><p><em>This is all working off of a basis of what I know and understand, so take things with a grain of salt!</em></p><h2 id=the-problem-at-hand>The problem at hand<a hidden class=anchor aria-hidden=true href=#the-problem-at-hand>#</a></h2><p>I&rsquo;m hoping to make a new module in VCV Rack (currently named Kyle) to act as a <a href=https://en.wikipedia.org/wiki/Dynamic_range_compression#Side-chaining>sidechaining</a> module. Sidechaining is the technology that allows for music to automatically become quieter when a DJ is talking, or for other instruments to &ldquo;step to the side&rdquo; and quiet down each time the bass drum comes in to give it extra &ldquo;oomph&rdquo;. Typically, this can be done by creating an <a href=https://en.wikipedia.org/wiki/Envelope_(music)>envelope</a> for a signal, and passing an inverse that as the level to another signal, to move the volume of the latter down when the former is up.</p><p>This is admittedly <em>extremely easy</em>, but I wanted to focus on more abstract sounds. This would focus on signals where an envelope cannot be easily defined and/or signals where I am too lazy to create an envelope for. This is where an envelope detector can come in handy.</p><h2 id=what-is-an-envelope-detector>What is an envelope detector<a hidden class=anchor aria-hidden=true href=#what-is-an-envelope-detector>#</a></h2><p>An <a href=https://en.wikipedia.org/wiki/Envelope_detector>envelope detector</a> is a tool that will map the envelope of a given waveform. The exact version of this would be an &ldquo;analytic signal&rdquo;, but this tool and its multiple iterations aim to replicate that analytic signal as accurately as possible.</p><p><figure><img src=/img/2212env.png alt="Envelope of a signal example" style=width:80%;display:block;margin:auto><figcaption style=text-align:center;font-style:italic>Example envelope from a signal, marked in red</figcaption></figure></p><p>There are a few approaches to getting this result, each with their own pros and cons. The most important trait for my implementation would be reactivity, followed of course by accuracy. Any substantial delay would ruin the use of the sidechain envelope, so even with accuracy the result would be unusable.</p><h2 id=how-can-it-be-implemented>How can it be implemented<a hidden class=anchor aria-hidden=true href=#how-can-it-be-implemented>#</a></h2><p>These are a few that I found while researching:</p><h3 id=diode-detector>Diode detector<a hidden class=anchor aria-hidden=true href=#diode-detector>#</a></h3><p>This is the simplest implementation, and probably the easiest to understand. A waveform is passed through a capacitor in a simple circuit, which charges whenever there is a high in the signal, and drains whenever there is a low. This allows it to create an almost sawtooth wave covering the envelope of a wave.</p><p><figure><img src=/img/2212diode.png alt="Example implementation of a diode detector" style=width:80%;display:block;margin:auto><figcaption style=text-align:center;font-style:italic>Example implementation of a diode detector, and its downfalls</figcaption></figure></p><p>As seen above though, some issues arise in its implementation. The aggression of the fall in the created envelope depends on how fast the capacitor loses charge, so if it doesn&rsquo;t lose charge fast enough, as seen above, there may be a large gap between the waveform dropping and the envelope following. This is still quite useful to consider, since it is easy to implement and reacts to rises immediately, so it may be usable given some modifications.</p><h3 id=rectifier-and-low-pass-filter>Rectifier and low-pass filter<a hidden class=anchor aria-hidden=true href=#rectifier-and-low-pass-filter>#</a></h3><p>This is where things get not-so-simple. Both this and the following method dive into some actual signal modulation to create an envelope from the original signal. I am also not the most knowledgable in this so please refer to this article&rsquo;s header. From this point on, we get into signals. Most of the base information I got was from <a href=https://www.mathworks.com/help/dsp/ug/envelope-detection.html>this MathWorks link</a>. Beware.</p><p>This is the basic chain of this operation:</p><p>$$\text{Input} \rightarrow u^2 \rightarrow u*2 \rightarrow \text{Downsample} \rightarrow \text{LPF} \rightarrow \sqrt{u} \rightarrow \text{Output}$$</p><p>The <strong>input</strong> to this is the original sound waveform. This signal is <strong>rectified</strong> (or squared), to essentially make it its own carrier wave. <a href=https://en.wikipedia.org/wiki/Rectifier>Rectifying</a>, for our understanding, mainly takes the loud sound wave and brings it back to a much smoother wave. From there, the signal is <strong>multiplied by 2</strong> to help scale it up for processing, and <strong>downsampled</strong>. <a href=https://en.wikipedia.org/wiki/Downsampling_(signal_processing)>Downsampling</a> removes some sampled data points, to simulate a lower sample rate and reduce the complexity of our resulting wave. Finally, a LPF, or <strong>Low Pass Filter</strong> is applied. A <a href=https://en.wikipedia.org/wiki/Low-pass_filter>Low Pass Filter</a> allows for low frequency waves, like our resulting wave, to pass through, and prevents high-frequency waves, like any small fast bumps in that wave, to be <em>smoothed out</em>. Finally, we <strong>take the square root</strong> of the resulting signal to scale it back down and match it to our original data.</p><p>This process definitely take some steps up in complexity, but it is really interesting on how it modulates the original waveform. Doing downsampling and (mainly) filtering in real time can sometimes be an issue in terms of delay, but this is something we can investigate.
Essentially, this is a lot more accurate than our previous method, but a lot more expensive.</p><h3 id=hilbert-transform>Hilbert Transform<a hidden class=anchor aria-hidden=true href=#hilbert-transform>#</a></h3><p>I am going to save the deepdive on this. This is something you can check out on the <a href=https://www.mathworks.com/help/dsp/ug/envelope-detection.html>original MathWorks link</a>, but it is essentially a more grandiose version of our rectifier and LPF described above. This one is seriously impressive, but again, is more computationally expensive. The main problem is that a <a href=https://www.nature.com/articles/s41598-021-97560-5>real time Hilbert Transform</a> is a point of high-level research, and as well that its main focus is on waveforms without massive changes. This does not match our use case.</p><p>Really cool though.</p><h2 id=what-i-would-like-to-do>What I would like to do<a hidden class=anchor aria-hidden=true href=#what-i-would-like-to-do>#</a></h2><p>As mentioned above, each piece has their pros and cons. The main things I want to keep in mind though are the following:</p><ul><li>This is for a real-time sidechaining module, so delay would be easily noticeable, and the ideal case would be if we could even be <em>early</em>.</li><li>This will be a VCV Rack module at the end of the day, so we will be sharing computer resources with a wide range of other modules. Something computationally expensive may be neat in its own physical module, but would be rude in this context.</li></ul><p>With these in mind, I would mainly want to focus on an <em>advanced</em> version of the diode detector, maybe with some peak detection so we could be aware of jumps from high to low frequencies. The best way to discover what&rsquo;s best would be through testing though, so that&rsquo;s what&rsquo;s next currently.</p><h2 id=what-i-am-doing>What I am doing<a hidden class=anchor aria-hidden=true href=#what-i-am-doing>#</a></h2><p><em>Note that this is a stream of consciousness as I&rsquo;ve been updating the module over time.</em></p><p>Now, for setting up a testing environment on waveform manipulation, I highly recommend looking towards Python with Scipy and MatPlotLib, so you can easily adjust parameters and see how different functions work on different waveforms. I did not do this though because I like to dive directly into the use case and also I wanted to keep momentum on this project without getting slowed down from importing different .WAVs to test on.</p><p>So, alternatively, I have made a rough version of this future module to test directly in VCV Rack. I am also using <a href=https://library.vcvrack.com/Fundamental/Scope>VCV Rack&rsquo;s Scope</a> to view the waveform I am creating, as well as <a href=https://library.vcvrack.com/AudibleInstruments/Plaits>Audible Instrument&rsquo;s Macro Oscillator 2</a> (or as many of us formally know it, Plaits).</p><p><figure><img src=/img/2301kyle1.png alt="First testing deployment, with prototype Kyle module" style=width:80%;display:block;margin:auto><figcaption style=text-align:center;font-style:italic>First testing deployment, with prototype Kyle module</figcaption></figure></p><h3 id=t1-diode-detector-with-rectifier>T1: Diode Detector with Rectifier<a hidden class=anchor aria-hidden=true href=#t1-diode-detector-with-rectifier>#</a></h3><p>To start testing, the Kyle module was fitted with a diode detector implementation. This was obviously the easiest to implement, but it was also what I believed would be the closest to the final implementation of the model.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Abs the current value, make all peaks positive
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>currVoltage <span style=color:#f92672>=</span> abs(inputs[SIGNAL_INPUT].getVoltage());
</span></span><span style=display:flex><span><span style=color:#75715e>// Set the output
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If the signal is greater than the current output voltage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (currVoltage <span style=color:#f92672>&gt;</span> outVoltage)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Set the output to the signal voltage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    outVoltage <span style=color:#f92672>=</span> currVoltage;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// If the current output voltage is greater than the signal
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Reduce the output by a given decay value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    outVoltage <span style=color:#f92672>-=</span> params[PDECAY_PARAM].getValue() <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// Set the output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>outputs[ENV_OUTPUT].setVoltage(outVoltage);
</span></span></code></pre></div><p>I had set the module to take any signal as an input and rectify it so all peaks were positive. Then, as the signal is running, the module would either clone the signal if the voltage was higher than its current voltage, or decay at a constant amount, ranging from 0 to 1/1000 per sample, depending on the <code>decay</code> knob value.</p><p><figure><img src=/img/2301kyle2.png alt="Kyle module running as basic diode detector" style=width:80%;display:block;margin:auto><figcaption style=text-align:center;font-style:italic>Kyle module running as basic diode detector</figcaption></figure></p><p>The decay, as expected, was extremely rigid. Hugging a waveform without some sort of exponential decay would definitely be an issue down the line. We could introduce some complexity into how we handle change in the waveform such as&mldr;</p><ul><li>Exponential/logarithmic decay</li><li>Decay based on current voltage (stronger at higher voltage, weaker at lower)</li><li>Moving window decay (alternative of the above, looking at how radically the data changes over a certain historical period and adjusting the decay rate accordingly)</li></ul><p>Furthermore, the rigid nature of the waveform seems to really come to a head at near-constant or low change areas of the signal waveform, namely at the low voltages of our test. This is somewhere that the current voltage decay basing and/or moving window could come in handy.</p><p>With all of this, the next implementation of the Kyle module would include some controls for toggling between exponential or linear decay, as well as altering decay based on current voltage. The moving window is something I find interesting, but will be looked at down the line if necessary.</p><h3 id=t2-diode-detector-with-mass-adjustment-parameters>T2: Diode Detector with Mass Adjustment Parameters<a hidden class=anchor aria-hidden=true href=#t2-diode-detector-with-mass-adjustment-parameters>#</a></h3><p>Next try, new controls! Things have gotten undeniably worse visually but that&rsquo;s what prototyping is for! Added in now are controls to change the decay type between exponential, linear, and logarithmic, as well as a knob to control how much the current voltage affects how fast the decay takes place.</p><p><figure><img src=/img/2301kyle3.png alt="Upgraded Kyle module with more decay controls" style=width:80%;display:block;margin:auto><figcaption style=text-align:center;font-style:italic>Upgraded Kyle module with more decay controls</figcaption></figure></p><p>Some immediate roadblocks were shown, mainly in having a constant exponential or logarithmic decay. When tweaking the <code>decay</code> knob, you could get a good curve to hug any quickly dropping high peaks, but whenever the voltage reached much lower values than that peak, there would be a <em>fuzz</em> of the curve immediately dropping from the low voltage, to somewhere much lower than the original waveform, and then bouncing back up. This was the wake-up call that reminded me that I would <strong>need</strong> to make the exponential and logarithmic decays relative to the voltages of the original signal, rather than keep it as its own knob.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Exponential, return function of time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>expDecay</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// e^(t * decay) * currVoltage / 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> exp(t <span style=color:#f92672>*</span> (params[PDECAY_PARAM].getValue() <span style=color:#f92672>*</span> <span style=color:#ae81ff>10.f</span>)) <span style=color:#f92672>*</span> (currVoltage <span style=color:#f92672>/</span> <span style=color:#ae81ff>7500.f</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Linear, return constant decay
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>linDecay</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// linear, just decay
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> params[PDECAY_PARAM].getValue() <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000.f</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Logarithmic, return function of time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>logDecay</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// log(t * decay) * currVoltage / 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>max(<span style=color:#ae81ff>0.f</span>, log(t <span style=color:#f92672>*</span> (params[PDECAY_PARAM].getValue() <span style=color:#f92672>*</span> <span style=color:#ae81ff>10.f</span>)) <span style=color:#f92672>*</span> (currVoltage <span style=color:#f92672>/</span> <span style=color:#ae81ff>10.f</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I also realized that my terminology was off. The curves that I was looking to model in the decay were ones bowing inward and outwards, but the <code>exp</code> and <code>log</code> decay curves both curve outwards. To get the curves I wanted, I would be looking at an <code>exp</code> and inverse <code>exp</code> function. Because of this, and after some testing, I realized the UI could be better by having one knob control the acceleration of the curve while the other can scale the entire decay function:</p><p>$$\text{decay}*e^{\text{accel}}$$</p><p>The decay knob would stay as-is, and the selector would then be replaced by the acceleration knob, or what will likely just be labelled <code>exp</code>. The voltage impact knob as seen on this demo will be removed since it is unneeded.</p><p>Something else I was wondering about was if we used inverse exponential decay at high amplitudes and regular exponential decay at low amplitudes, but that may be more complicated than it&rsquo;s worth and would need to introduce more controls. I&rsquo;ll mainly be looking at how the above works in the next iteration.</p><h3 id=t3-exponential-decay-diode-detector>T3: Exponential Decay Diode Detector<a hidden class=anchor aria-hidden=true href=#t3-exponential-decay-diode-detector>#</a></h3><p><strong>IT MODERATELY WORKS!</strong> This is the first iteration that I am happy to use as a base to tweak for final release. Since the last try, I implemented the <code>exp</code> knob as described above. Negative values make it curve in while positive values make it curve out. I also added an amplification knob to multiply the output, allowing even small changes to be much more impactful for sidechain usage.</p><p><figure><img src=/img/2301kyle4.png alt="First functional Kyle module with exponent customization" style=width:80%;display:block;margin:auto><figcaption style=text-align:center;font-style:italic>First functional Kyle module with exponent customization</figcaption></figure></p><p>This time around, the code has gotten quite neat and compact, to the point I can put the whole process code here pretty comfortably. Some notable changes are now scaling the decay value in relation to the sample rate to keep things consistent at different values, as well as finally implementing the inverse envelope to allow for level/VCA modulation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Get input voltage (keep it positive)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>currVoltage <span style=color:#f92672>=</span> abs(inputs[SIGNAL_INPUT].getVoltage());
</span></span><span style=display:flex><span><span style=color:#75715e>// Add to the timer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>t <span style=color:#f92672>+=</span> args.sampleTime;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    We decay the signal either exponentially if PEXP != 0,
</span></span></span><span style=display:flex><span><span style=color:#75715e>    otherwise we decay linearly
</span></span></span><span style=display:flex><span><span style=color:#75715e>    out - (decay * e^(exp))
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>outVoltage <span style=color:#f92672>=</span> outVoltage <span style=color:#f92672>-</span> ((params[PDECAY_PARAM].getValue() <span style=color:#f92672>/</span> args.sampleRate) <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>                            exp((params[PEXP_PARAM].getValue() <span style=color:#f92672>*</span> t)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    If the original signal is greater than our output voltage,
</span></span></span><span style=display:flex><span><span style=color:#75715e>        currVoltage &gt; outVoltage
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Set the output to the signal voltage. Otherwise, use the
</span></span></span><span style=display:flex><span><span style=color:#75715e>    decayed output voltage
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (currVoltage <span style=color:#f92672>&gt;=</span> outVoltage)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    outVoltage <span style=color:#f92672>=</span> currVoltage;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Reset the time
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    t <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.f</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>outVoltage <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(currVoltage, outVoltage);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Amplify the output (maxing out at 10)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ampOut <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>min(<span style=color:#ae81ff>10.f</span>, abs(outVoltage <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>9.f</span> <span style=color:#f92672>*</span> params[PAMP_PARAM].getValue())));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Set output voltages, accounting for amplification
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>outputs[ENV_OUTPUT].setVoltage(ampOut);
</span></span><span style=display:flex><span>outputs[ENVINV_OUTPUT].setVoltage(<span style=color:#ae81ff>10</span> <span style=color:#f92672>-</span> ampOut);
</span></span></code></pre></div><p>As usual, there is always more to fix and improve on.</p><p>Using a negative exponent is very cool for hugging a shrinking waveform without ever needing to hit that waveform until the next peak, but at high negative values and low decay values it does not converge to 0. This is also seen with a constant decay and decay set to 0. This could likely be fixed by checking if the input has been at or around 0 for a number of samples, and/or if anything is plugged into the unit. If this is the case, we can slowly decay the value to 0 or just jump it.</p><p>As mentioned in the last iteration, there could be a use for using both positive and negative exponential decay values depending on the current voltage of the signal, but I will likely leave that for a revamp of the module in the future (which I can then change $20 more for).</p><p>I was also thinking of the possibility of adding a <code>max</code> and <code>min</code> value, scaling all voltages from the original signal above <code>max</code> to an output of 10V, all voltages below <code>min</code> to an output of 0V, and appropriately matching the central values. I&rsquo;m gonna run this all by some people to see how useful it could be and if it&rsquo;s worthwhile to implement.</p><p>The final thing to touch upon would probably be some iconography to help visually explain what different exponent values and even amplification values mean, there&rsquo;s enough room for it too so why not.</p><h2 id=where-from-here>Where from here<a hidden class=anchor aria-hidden=true href=#where-from-here>#</a></h2><p>I think Kyle has reached a stable enough point for a base release, with a lot to think on for a future refactor. Once this module releases, the Kyle, Sesame, and Lola modules will all be reviewed to add in any extra features as well as resource test to confirm they&rsquo;ll work well in VCV Rack. Finally, assuming all this goes well, they&rsquo;ll be submitted to the <a href=https://library.vcvrack.com/>VCV Library</a>. Until then, I write.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://loparcog.github.io/tags/synth/>synth</a></li><li><a href=https://loparcog.github.io/tags/research/>research</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://loparcog.github.io/>Giacomo</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>