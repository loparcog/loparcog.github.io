<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Envelope Detector Research and Ramblings ✉️ | giacomo</title><meta name=keywords content="synth,research"><meta name=description content="Looking into different envelope detecting methods for a future sidechaining module"><meta name=author content="Giacomo Loparco"><link rel=canonical href=https://loparcog.github.io/posts/2212envelope/><link crossorigin=anonymous href=/assets/css/stylesheet.f417b2b78a51a3f1015eb588a750379d079f7aca74d3fc689d30c120942e444c.css integrity="sha256-9Beyt4pRo/EBXrWIp1A3nQefesp00/xonTDBIJQuREw=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://loparcog.github.io/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://loparcog.github.io/img/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://loparcog.github.io/img/favicon-32x32.png><link rel=apple-touch-icon href=https://loparcog.github.io/img/apple-touch-icon.png><link rel=mask-icon href=https://loparcog.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><meta property="og:title" content="Envelope Detector Research and Ramblings ✉️"><meta property="og:description" content="Looking into different envelope detecting methods for a future sidechaining module"><meta property="og:type" content="article"><meta property="og:url" content="https://loparcog.github.io/posts/2212envelope/"><meta property="og:image" content="https://loparcog.github.io/img/pfp.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-19T00:00:00+00:00"><meta property="article:modified_time" content="2022-12-19T00:00:00+00:00"><meta property="og:site_name" content="giacomo"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://loparcog.github.io/img/pfp.png"><meta name=twitter:title content="Envelope Detector Research and Ramblings ✉️"><meta name=twitter:description content="Looking into different envelope detecting methods for a future sidechaining module"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://loparcog.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Envelope Detector Research and Ramblings ✉️","item":"https://loparcog.github.io/posts/2212envelope/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Envelope Detector Research and Ramblings ✉️","name":"Envelope Detector Research and Ramblings ✉️","description":"Looking into different envelope detecting methods for a future sidechaining module","keywords":["synth","research"],"articleBody":"This is all working off of a basis of what I know and understand, so take things with a grain of salt!\nThe problem at hand I’m hoping to make a new module in VCV Rack (currently named Kyle) to act as a sidechaining module. Sidechaining is the technology that allows for music to automatically become quieter when a DJ is talking, or for other instruments to “step to the side” and quiet down each time the bass drum comes in to give it extra “oomph”. Typically, this can be done by creating an envelope for a signal, and passing an inverse that as the level to another signal, to move the volume of the latter down when the former is up.\nThis is admittedly extremely easy, but I wanted to focus on more abstract sounds. This would focus on signals where an envelope cannot be easily defined and/or signals where I am too lazy to create an envelope for. This is where an envelope detector can come in handy.\nWhat is an envelope detector An envelope detector is a tool that will map the envelope of a given waveform. The exact version of this would be an “analytic signal”, but this tool and its multiple iterations aim to replicate that analytic signal as accurately as possible.\nExample envelope from a signal, marked in red There are a few approaches to getting this result, each with their own pros and cons. The most important trait for my implementation would be reactivity, followed of course by accuracy. Any substantial delay would ruin the use of the sidechain envelope, so even with accuracy the result would be unusable.\nHow can it be implemented These are a few that I found while researching:\nDiode detector This is the simplest implementation, and probably the easiest to understand. A waveform is passed through a capacitor in a simple circuit, which charges whenever there is a high in the signal, and drains whenever there is a low. This allows it to create an almost sawtooth wave covering the envelope of a wave.\nExample implementation of a diode detector, and its downfalls As seen above though, some issues arise in its implementation. The aggression of the fall in the created envelope depends on how fast the capacitor loses charge, so if it doesn’t lose charge fast enough, as seen above, there may be a large gap between the waveform dropping and the envelope following. This is still quite useful to consider, since it is easy to implement and reacts to rises immediately, so it may be usable given some modifications.\nRectifier and low-pass filter This is where things get not-so-simple. Both this and the following method dive into some actual signal modulation to create an envelope from the original signal. I am also not the most knowledgable in this so please refer to this article’s header. From this point on, we get into signals. Most of the base information I got was from this MathWorks link. Beware.\nThis is the basic chain of this operation:\n$$\\text{Input} \\rightarrow u^2 \\rightarrow u*2 \\rightarrow \\text{Downsample} \\rightarrow \\text{LPF} \\rightarrow \\sqrt{u} \\rightarrow \\text{Output}$$\nThe input to this is the original sound waveform. This signal is rectified (or squared), to essentially make it its own carrier wave. Rectifying, for our understanding, mainly takes the loud sound wave and brings it back to a much smoother wave. From there, the signal is multiplied by 2 to help scale it up for processing, and downsampled. Downsampling removes some sampled data points, to simulate a lower sample rate and reduce the complexity of our resulting wave. Finally, a LPF, or Low Pass Filter is applied. A Low Pass Filter allows for low frequency waves, like our resulting wave, to pass through, and prevents high-frequency waves, like any small fast bumps in that wave, to be smoothed out. Finally, we take the square root of the resulting signal to scale it back down and match it to our original data.\nThis process definitely take some steps up in complexity, but it is really interesting on how it modulates the original waveform. Doing downsampling and (mainly) filtering in real time can sometimes be an issue in terms of delay, but this is something we can investigate. Essentially, this is a lot more accurate than our previous method, but a lot more expensive.\nHilbert Transform I am going to save the deepdive on this. This is something you can check out on the original MathWorks link, but it is essentially a more grandiose version of our rectifier and LPF described above. This one is seriously impressive, but again, is more computationally expensive. The main problem is that a real time Hilbert Transform is a point of high-level research, and as well that its main focus is on waveforms without massive changes. This does not match our use case.\nReally cool though.\nWhat I would like to do As mentioned above, each piece has their pros and cons. The main things I want to keep in mind though are the following:\nThis is for a real-time sidechaining module, so delay would be easily noticeable, and the ideal case would be if we could even be early. This will be a VCV Rack module at the end of the day, so we will be sharing computer resources with a wide range of other modules. Something computationally expensive may be neat in its own physical module, but would be rude in this context. With these in mind, I would mainly want to focus on an advanced version of the diode detector, maybe with some peak detection so we could be aware of jumps from high to low frequencies. The best way to discover what’s best would be through testing though, so that’s what’s next currently.\n","wordCount":"963","inLanguage":"en","datePublished":"2022-12-19T00:00:00Z","dateModified":"2022-12-19T00:00:00Z","author":{"@type":"Person","name":"Giacomo Loparco"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://loparcog.github.io/posts/2212envelope/"},"publisher":{"@type":"Organization","name":"giacomo","logo":{"@type":"ImageObject","url":"https://loparcog.github.io/img/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://loparcog.github.io/ accesskey=h title="giacomo (Alt + H)">giacomo</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://loparcog.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://loparcog.github.io/archives/ title=archives><span>archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://loparcog.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://loparcog.github.io/posts/>Posts</a></div><h1 class=post-title>Envelope Detector Research and Ramblings ✉️</h1><div class=post-meta><span title='2022-12-19 00:00:00 +0000 UTC'>December 19, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Giacomo Loparco</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#the-problem-at-hand>The problem at hand</a></li><li><a href=#what-is-an-envelope-detector>What is an envelope detector</a></li><li><a href=#how-can-it-be-implemented>How can it be implemented</a><ul><li><a href=#diode-detector>Diode detector</a></li><li><a href=#rectifier-and-low-pass-filter>Rectifier and low-pass filter</a></li><li><a href=#hilbert-transform>Hilbert Transform</a></li></ul></li><li><a href=#what-i-would-like-to-do>What I would like to do</a></li></ul></nav></div></details></div><div class=post-content><p><em>This is all working off of a basis of what I know and understand, so take things with a grain of salt!</em></p><h2 id=the-problem-at-hand>The problem at hand<a hidden class=anchor aria-hidden=true href=#the-problem-at-hand>#</a></h2><p>I&rsquo;m hoping to make a new module in VCV Rack (currently named Kyle) to act as a <a href=https://en.wikipedia.org/wiki/Dynamic_range_compression#Side-chaining>sidechaining</a> module. Sidechaining is the technology that allows for music to automatically become quieter when a DJ is talking, or for other instruments to &ldquo;step to the side&rdquo; and quiet down each time the bass drum comes in to give it extra &ldquo;oomph&rdquo;. Typically, this can be done by creating an <a href=https://en.wikipedia.org/wiki/Envelope_(music)>envelope</a> for a signal, and passing an inverse that as the level to another signal, to move the volume of the latter down when the former is up.</p><p>This is admittedly <em>extremely easy</em>, but I wanted to focus on more abstract sounds. This would focus on signals where an envelope cannot be easily defined and/or signals where I am too lazy to create an envelope for. This is where an envelope detector can come in handy.</p><h2 id=what-is-an-envelope-detector>What is an envelope detector<a hidden class=anchor aria-hidden=true href=#what-is-an-envelope-detector>#</a></h2><p>An <a href=https://en.wikipedia.org/wiki/Envelope_detector>envelope detector</a> is a tool that will map the envelope of a given waveform. The exact version of this would be an &ldquo;analytic signal&rdquo;, but this tool and its multiple iterations aim to replicate that analytic signal as accurately as possible.</p><p><figure><img src=/img/2212env.png alt="Envelope of a signal example" style=width:100%;display:block;margin:auto><figcaption style=text-align:center;font-style:italic>Example envelope from a signal, marked in red</figcaption></figure></p><p>There are a few approaches to getting this result, each with their own pros and cons. The most important trait for my implementation would be reactivity, followed of course by accuracy. Any substantial delay would ruin the use of the sidechain envelope, so even with accuracy the result would be unusable.</p><h2 id=how-can-it-be-implemented>How can it be implemented<a hidden class=anchor aria-hidden=true href=#how-can-it-be-implemented>#</a></h2><p>These are a few that I found while researching:</p><h3 id=diode-detector>Diode detector<a hidden class=anchor aria-hidden=true href=#diode-detector>#</a></h3><p>This is the simplest implementation, and probably the easiest to understand. A waveform is passed through a capacitor in a simple circuit, which charges whenever there is a high in the signal, and drains whenever there is a low. This allows it to create an almost sawtooth wave covering the envelope of a wave.</p><p><figure><img src=/img/2212diode.png alt="Example implementation of a diode detector" style=width:100%;display:block;margin:auto><figcaption style=text-align:center;font-style:italic>Example implementation of a diode detector, and its downfalls</figcaption></figure></p><p>As seen above though, some issues arise in its implementation. The aggression of the fall in the created envelope depends on how fast the capacitor loses charge, so if it doesn&rsquo;t lose charge fast enough, as seen above, there may be a large gap between the waveform dropping and the envelope following. This is still quite useful to consider, since it is easy to implement and reacts to rises immediately, so it may be usable given some modifications.</p><h3 id=rectifier-and-low-pass-filter>Rectifier and low-pass filter<a hidden class=anchor aria-hidden=true href=#rectifier-and-low-pass-filter>#</a></h3><p>This is where things get not-so-simple. Both this and the following method dive into some actual signal modulation to create an envelope from the original signal. I am also not the most knowledgable in this so please refer to this article&rsquo;s header. From this point on, we get into signals. Most of the base information I got was from <a href=https://www.mathworks.com/help/dsp/ug/envelope-detection.html>this MathWorks link</a>. Beware.</p><p>This is the basic chain of this operation:</p><p>$$\text{Input} \rightarrow u^2 \rightarrow u*2 \rightarrow \text{Downsample} \rightarrow \text{LPF} \rightarrow \sqrt{u} \rightarrow \text{Output}$$</p><p>The <strong>input</strong> to this is the original sound waveform. This signal is <strong>rectified</strong> (or squared), to essentially make it its own carrier wave. <a href=https://en.wikipedia.org/wiki/Rectifier>Rectifying</a>, for our understanding, mainly takes the loud sound wave and brings it back to a much smoother wave. From there, the signal is <strong>multiplied by 2</strong> to help scale it up for processing, and <strong>downsampled</strong>. <a href=https://en.wikipedia.org/wiki/Downsampling_(signal_processing)>Downsampling</a> removes some sampled data points, to simulate a lower sample rate and reduce the complexity of our resulting wave. Finally, a LPF, or <strong>Low Pass Filter</strong> is applied. A <a href=https://en.wikipedia.org/wiki/Low-pass_filter>Low Pass Filter</a> allows for low frequency waves, like our resulting wave, to pass through, and prevents high-frequency waves, like any small fast bumps in that wave, to be <em>smoothed out</em>. Finally, we <strong>take the square root</strong> of the resulting signal to scale it back down and match it to our original data.</p><p>This process definitely take some steps up in complexity, but it is really interesting on how it modulates the original waveform. Doing downsampling and (mainly) filtering in real time can sometimes be an issue in terms of delay, but this is something we can investigate.
Essentially, this is a lot more accurate than our previous method, but a lot more expensive.</p><h3 id=hilbert-transform>Hilbert Transform<a hidden class=anchor aria-hidden=true href=#hilbert-transform>#</a></h3><p>I am going to save the deepdive on this. This is something you can check out on the <a href=https://www.mathworks.com/help/dsp/ug/envelope-detection.html>original MathWorks link</a>, but it is essentially a more grandiose version of our rectifier and LPF described above. This one is seriously impressive, but again, is more computationally expensive. The main problem is that a <a href=https://www.nature.com/articles/s41598-021-97560-5>real time Hilbert Transform</a> is a point of high-level research, and as well that its main focus is on waveforms without massive changes. This does not match our use case.</p><p>Really cool though.</p><h2 id=what-i-would-like-to-do>What I would like to do<a hidden class=anchor aria-hidden=true href=#what-i-would-like-to-do>#</a></h2><p>As mentioned above, each piece has their pros and cons. The main things I want to keep in mind though are the following:</p><ul><li>This is for a real-time sidechaining module, so delay would be easily noticeable, and the ideal case would be if we could even be <em>early</em>.</li><li>This will be a VCV Rack module at the end of the day, so we will be sharing computer resources with a wide range of other modules. Something computationally expensive may be neat in its own physical module, but would be rude in this context.</li></ul><p>With these in mind, I would mainly want to focus on an <em>advanced</em> version of the diode detector, maybe with some peak detection so we could be aware of jumps from high to low frequencies. The best way to discover what&rsquo;s best would be through testing though, so that&rsquo;s what&rsquo;s next currently.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://loparcog.github.io/tags/synth/>synth</a></li><li><a href=https://loparcog.github.io/tags/research/>research</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://loparcog.github.io/>giacomo</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>